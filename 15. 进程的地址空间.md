

在我们的状态机模型中，进程的状态由**内存和寄存器**组成。寄存器是非常明确的，gdb 中 info registers 即可查看。  
但进程 “平坦” 的地址空间 里到底有什么，以及我们是否可以 “入侵” 另一个进程的地址空间？

## 15.1 进程的地址空间

ag:  
怎样查看 Linux 进程的地址空间？
/proc/xxxx, pmap , vmap, gdb 

ag:  
我们能 “控制” pmap 的输出吗？
修改堆 (bss) 内存的大小
在栈上分配大数组…


如何仅用 x86-64 汇编调用 Linux 系统调用，输出 Hello World 并退出？

## 15.2 入侵进程地址空间
金山游侠
* gdb
* Profiler (perf)

## 15.3 给进程发送 GUI 事件
 
按键精灵：实现按键精灵不必入侵进程的地址空间。  
操作系统管理了 I/O 设备，我们相应模拟出按键的事件即可。  
当然，我们也可以为进程像游戏修改器那样注入按键事件。

#### 给进程发送键盘/鼠标事件
做个驱动 (可编程键盘/鼠标)  
利用操作系统/窗口管理器提供的 API
* xdotool
(我们用这玩意测试 vscode 的插件)
* ydotool
* evdev (按键显示脚本；主播常用)
  
2024 年的应用：实现 AI Copilot Agent  
文本/截图 → AI 分析 → 执行动作

## 15.4 改变进程对时间的感知

程序 = 状态机  
“计算指令” 是不能感知时间的  
spin count 计时会出现 “机器变快，游戏没法玩” 的情况  
syscall 是感知时间的唯一方法  
“劫持” 和时间相关的 syscall/库函数  
改变程序对时间的认知  
就像手表调快/慢了一样

**变速齿轮代码注入**  
用一段代码 “勾住” (hook) 函数的执行
* 然后就可以入侵程序逻辑 (从而为所欲为) 了


变速齿轮：通过 “劫持” 时间相关的函数或系统调用，例如 toybox.h 使用的 gettimeofday，
我们就可以人为调节应用程序的时钟。  
注意真实的应用程序访问时钟的方式是多样的，可能通过设置闹钟，
或是通过接收窗口管理器的时钟事件。

软件动态更新：我们可以通过 patch 函数的头部为一个跳转实现对一个函数的 “运行时热更新”。


  
状态机的视角自然地将我们引入 “内存到底是什么” 的问题——它的答案同样也很自然：带有访问权限控制的连续内存段。  
我们可以通过 mmap、munmap、mprotect 三个系统调用调整状态机的地址空间，包括分配匿名的内存、映射文件内容到内存、修改访问权限等。  
更有趣的是操作系统有 “能够实现一切应用程序” 的需求，调试器也不在话下——这也给了我们入侵其他进程地址空间的机制。


阅读材料  
教科书 Operating Systems: Three Easy Pieces：

第 12 章 - Dialogue  
第 13 章 - Address Spaces  
第 14 章 - Memory API

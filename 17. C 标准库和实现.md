
本讲内容：系统调用之上的世界：C 标准库和实现。


## 17.1 libc 简介
### 如何 “实现” 一个 libc？
```
Freestanding shell 里就有一个迷你 “libc”
系统调用
syscall
(通常系统调用封装成 C 函数)
库函数
strlen, zalloc, ...
_start
“C Runtime Library”
-Wl,--verbose 时可以看到链接列表：Scrt1.o, crti.o, crtendS.o
```
### 学习已有 libc 的实现 
调试 glibc？
不，你不想  
glibc 的代码有非常沉重的历史包袱  
以及非常多的优化——都是对 “理解原理” 的阻碍  
新手阅读体验极差  
基本原则：总有办法的  

让 AI Copilot 帮你解释代码 (这个可以有)  
是否有比 glibc 更适合学习的 libc 实现？  
(我承认我不如 AI)  
幸好我还做了正确的选择：musl

### 学习已有 libc 的实现 (cont'd)
**下载源码不难，难的是怎么 “使用” 下载的 libc**

我们知道可以使用 gcc 和 ld  
但到底应该用什么编译选项？  

**如何使用我自己的 clang、musl 替代 glibc 编译程序？**  
当然，我们还是选择自己编译
比较重要的选项
-O1: 减少优化级别，便于查看状态
-g3: 增加调试信息
使用 musl-gcc 静态编译
试一试：从第一条指令开始调试一个 C 程序

## 17.2 基础编程机制的抽象

```
@@TODO 
不是很理解

```
## 17.3 系统调用与环境的抽象



## 17.4 动态内存管理




